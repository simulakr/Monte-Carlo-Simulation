# -*- coding: utf-8 -*-
"""Monte_Carlo_Simulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DSn2Qf-8k0gxhsggvF_jgEzTxjm7ag54
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import yfinance as yf
from scipy.stats import norm

df = yf.download('NVDA', start='2018-01-01', end='2025-12-01')

df.columns = df.columns.get_level_values(0)

df.head()

df['Returns'] = df['Close'].pct_change()
df.head()

num_simulations = 10000
num_days = 22 #21

last_price = df['Close'].iloc[-1]

simulation_df = np.zeros((num_days, num_simulations))

mu = df['Returns'].mean()
sigma = df['Returns'].std()

for simulation in range(num_simulations):
    price_list = [last_price]

    for day in range(num_days):
        price = price_list[-1] * np.exp((mu - 0.5 * sigma**2) + sigma * np.random.normal())
        price_list.append(price)

    simulation_df[:, simulation] = price_list[1:]

final_prices = simulation_df[-1,:]

median_final_price = np.median(final_prices)

most_likely_simulation_index = np.argmin(np.abs(final_prices - median_final_price))
most_likely_simulation = simulation_df[:,most_likely_simulation_index]

plt.figure(figsize=(10,5))
plt.plot(simulation_df)
plt.title('Monte Carlo Simulation of NVDA Stock Price')
plt.xlabel('Days')
plt.ylabel('Price')
plt.show()

print(f"Last price is {last_price:.2f}")
print(f"Most likely simulation's final price is {most_likely_simulation[-1]:.2f}")
print(f"Most likely simulation's return is %{(most_likely_simulation[-1]/last_price -1)*100:.2f}")

plt.figure(figsize=(10,5))
plt.plot(most_likely_simulation)
plt.title('Most Likely Simulation')
plt.xlabel('Days')
plt.ylabel('Price')
plt.show()

def get_top_drawdowns(df, column='Close'):

    prices = df[column]
    running_max = prices.iloc[0]
    peak_idx = prices.index[0]

    drawdowns = []
    current_dd_min = 0
    trough_idx = prices.index[0]
    in_drawdown = False

    for i in range(len(prices)):
        price = prices.iloc[i]
        idx = prices.index[i]

        if price >= running_max:
            if in_drawdown:
                drawdowns.append({
                    'Peak Date': peak_idx.strftime('%Y-%m-%d'),
                    'Trough Date': trough_idx.strftime('%Y-%m-%d'),
                    'Recovery Date': idx.strftime('%Y-%m-%d'),
                    'Drawdown %': round(current_dd_min * 100, 2),
                    'Days to Recover': (idx - peak_idx).days
                })
                in_drawdown = False

            running_max = price
            peak_idx = idx
            current_dd_min = 0
        else:
            in_drawdown = True
            dd = (price - running_max) / running_max
            if dd < current_dd_min:
                current_dd_min = dd
                trough_idx = idx

    # Hala toparlanamamış düşüşü ekle
    if in_drawdown:
        drawdowns.append({
            'Peak Date': peak_idx.strftime('%Y-%m-%d'),
            'Trough Date': trough_idx.strftime('%Y-%m-%d'),
            'Recovery Date': "Still Recovering",
            'Drawdown %': round(current_dd_min * 100, 2),
            'Days to Recover': None
        })

    # DataFrame'e çevir ve en büyük 3 düşüşü getir
    dd_df = pd.DataFrame(drawdowns).sort_values(by='Drawdown %').head(3)

    # İndeksleri 1, 2, 3 diye sıralayalım
    dd_df.index = range(1, len(dd_df) + 1)

    return dd_df

top_3 = get_top_drawdowns(df, 'Close')
print(top_3)

"""* Eğer timeframe günlük değişse recovery time yerine recovery bars olacak.

* Recovery time hesaplaması sonra tekrar yapılacak.
"""
